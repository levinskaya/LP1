# Реферат
## по курсу "Логическое программирование"

### студент: Валов В.В

## ТЕМА Логические языки как первые языки для обучения программированию

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

#### Вступление

Программирование — одна из самых быстро развивающихся и наиболее перспективных отраслей компьютерных наук в наше время. По сравнению с другими профессиями программисты стали сильно востребованы относительно недавно. Вызвано это как стремительным развитием компьютерной науки в целом, так и внедрением вычислительных устройств практически в каждую область жизни человека.

Вопрос об изучении программирования наверняка задавал себе каждый из нас, кто испытывает хоть какой-то интерес к компьютерам. Выбор может пасть на само устройство компьютера: его аппаратную часть, «железо», компьютерную безопасность, устройство серверов; либо же, например, на написание программ, непосредственно взаимодействующих с пользователем: будь то операционные системы или приложения для смартфонов.

В любом случае, рано или поздно мы сталкиваемся с вопросами в духе: «с изучения какого языка программирования начать?», «какой язык сейчас наиболее востребован?», «почему один лучше другого?» и пр. Однако не стоит забывать и про то, что любой язык относится к какой-либо (или нескольким сразу) парадигме программирования, своеобразному «стилю» написания программы, подходу к решению задачи.

Поэтому прежде чем дать ответы на поставленные нами вопросы, сперва опишем основные парадигмы программирования, их историю развития и основные концепции, которые они несут в себе.

#### Основные виды ЯП, парадигмы, их различия

Быстрое развитие отрасли программирования начинается в 20 столетии, когда цифровые компьютеры начинают постепенно замещать старые, использующие перфокарты. Первые языки программирования для цифровых компьютеров стали появляться ближе к концу 40-х, началу 50-х годов, когда компьютеры ещё не широко использовались по всему миру. Самым первым высокоуровневым языком программирования, который существует и развивается и по сей день, является Fortran (сокращение с английского от Formula Translator). Использовался в основном учеными и оказал значительное влияние на развитие некоторых других языков.

Впервые термин «парадигма программирования» был употреблен Робертом Флойдом в 1978 году в одной из своих лекций. Дать определение этому понятию можно несколькими способами. Роганов В.Е. в своей книге «Основы информатики и программирования» дает определение парадигме программирования, как «способу концептуализации, который определяет, как следует проводить вычисления, и как работа, выполняемая компьютером, должна быть структурирована и организована». Иначе говоря, это стиль написания программы в самом общем понимании этого слова, то, какой логике подчиняется любое написанное программное обеспечение: преобладание функций, использование объектов-ориентированного подхода или нечто другое.

Всего в наше время насчитывается более 20 парадигм программирования, из которых можно выделить 4 основных и наиболее базовых (из которых в последствии образовались другие парадигмы): императивное, функциональное, логическое и объектно-ориентированное программирования.

Основная идея **императивного программирования** — это последовательное выполнение заранее заданных инструкций, при чем в каждый момент времени известно, какая инструкция должна быть выполнена следующей.

**Функциональное программирование** опирается на лямбда-исчисление, а программа в основаном состоит из функций и процедур.

При использовании **логического программирования** программист лишь формально описывает алгоритм при помощи некоторых правил и ограничений, а генерация решений полностью возлагается на плечи компьютера.

**Парадигма ООП** подразумевает использование объектов, обладающих некоторыми свойствами и способных взаимодействовать друг с другом посредством обращения к методам, функциям и полям классов.

Стоит отметить, что многие современные ЯП сочетают в себе несколько парадигм программирования, что добавляет им больше гибкости, а программистам даёт возможность подходить к решению задач совершенно разными способами в рамках одного языка. К примеру, один из самых популярных в наше время языков, Python, содержит в себе объектно-ориентированную, функциональную, императивную и еще несколько других парадигм программирования.

#### Первые логические языки программирования, особенности

Хотелось бы обратить особое внимание именно на декларативные языки и логическую парадигму программирования.

Первый язык логического программирования получил название Planner и возник практически спустя 12 лет после появления ЯП Fortran — в 1969 году, а в себе сочетал еще помимо логической функциональную парадигму программирования. Спустя 3 года — в 1972 году на свет появился язык Prolog, который в какой-то степени можно считать упрощением Planner“а. 

#### Применение логических языков программирования, основные задачи, которые они решают

Спектр задач, которые могут быть решены при помощи логических языков, точно такой же, как и в других языках ввиду эквивалентности их алгоритмических моделей. Однако на практике чисто декларативный подход не всегда удобно использовать: чаще всего подобные языки задействуются, когда решение относительно несложно описать при помощи логики предикатов.

#### Логические языки: совершенно другой подход к решению задач

#### Основы синтаксиса Prolog

Прежде чем привести примеры решений некоторых задач на языке Prolog, опишем его синтаксис и основные возможности.
В большинстве случаев программу можно разделить на 2 части:

1. Декларативная, в которой описаны некоторые факты, оперирование с которыми будет производится во время выполнения запроса.
2. Запросы, ответы на которые и есть результат выполнения программы.

*Замечание*: в частности, в иллюстрациях используются предикаты, совместимые с SWI-Prolog.

Пример описания некоторых фактов (правил) в декларативной части программы.
```prolog
eat(misha, fish).
eat(misha, bread).
eat(misha, chips).
eat(misha, burgers).

eat(masha, fruits).
eat(masha, vegetables).
```
В нашем случае `eat` - предикат (правило), определяющий, какую еду предпочитает конкретный человек.
`masha, misha, fish, bread и т.п.` - некоторые атомы (константы).

Ради примера можно описать предикат, который будет отвечать на запрос "является ли человек вегетарианцем, или нет":
```prolog
vegetarian(X):-
    not(eat(X, fish)),
    not(eat(X, burgers)).

eat_bad_food(Human):-
    eat(Human, chips);
    eat(Human, burgers).

```
Переменными в языке считается всё, что начинается с большой буквы (X, Human).
Знак ":-" можно интерпретировать как "если". То есть если истинно всё, что следует за этим знаком, то и сам предикат считается истинным.
Знак "," используется для логического "И", знак ";" - для "ИЛИ".

Если перевести описанные выше предикаты на естественный язык, то получатся следующие высказывания:
1. X является вегетарианцем, если (X не ест рыбу) И (X не ест бургеры).
2. Human ест плохую еду, если (Human ест чипсы) ИЛИ (Human ест бургеры).

Помимо стандартной логики предикатов, в язык Prolog встроена возможность использовать списки, что значительно расширяет его функциональность. Списки являются рекурсивной структурой, представляющей из себя "голову" - один элемент и "хвост" - другой список. Голова и хвост разделяются при помощи символа вертикальной черты "|", а сам список заключается в квадратные скобки.
Пустой список обозначается просто парой квадратных скобок "[]".

Для пример использования списков опишем предикат подсчета количества элементов в списке.

```prolog
length1([], 0).
length1([H|T], N):-
	length1(T, N1),
	N is N1 + 1.
```
Обратите внимание, что имя предиката заканчивается цифрой 1. Сделано это для предотвращения конфликта имен со встроенным предикатом `length` во многих реализациях интерпретаторов язык Prolog.
Порядок определения предикатов также имеет значение, проверка на соответствие происходит "сверху вниз".

Описать работу предикатов можно следующим образом:
- Если список пустой, то его длина 0
- Если список не пустой, то считаем длину его хвоста и добавляем к полученному значению 1.

Поскольку переменная во втором предикате `length1` никак не используется, то можно заменить её на специальное значение - анонимную переменную, которая обозначается символом нижнего подчеркивания "\_". Таким образом, второй предикат может быть переписан в виде
```prolog
length1([_|T], N):-
	length1(T, N1),
	N is N1 + 1.
```

Примеры запросов и ответов от интерпретатора к описанным выше программам:
```prolog
?- vegetarian(masha).
true.
?- vegetarian(misha).
false.
?- eat_bad_food(X).
X = misha.
?- length([1,2,3],Res).
Res = 3.
?- length([1,2,[3,4,5]],Res).
Res = 3.
```
Как видно из примера, списки в Прологе могут быть вложенными.

#### Примеры программы на Prolog и её аналоги на C++, Python
Каждый из языков обладает рядом преимуществ и недостатков и предназначен для решения определенного рода задач. Однако просто ради сравнения внешнего вида опишем программу по нахождению максимального элемента в списке (массиве) на языке Prolog и двух других языках - C++ и Python.

Prolog:
```prolog
max1([X], X).
max1([X1|Y], N):-
	max1(Y, X2),
	((X1 >= X2, N is X1); (X1 < X2, N is X2)).
```
C++:
```c++
for(int i = 0; i < array_size; i++){
	if(array[i] > maximum){
        	maximum = array[i];
        }
}
```
Python:
```python
for elem in array:
	if elem > maximum:
		maximum = elem
```
#### Самые популярные логические языки на данный момент

#### Преимущества
Языки логического программирования создавались, чтобы текст программы был максимально приближен к естественным языкам и человеческой модели рассуждения. Программы, написанные на декларативные языках достаточно просты в понимании. Как оказалось, для решения любой задачи на языке Prolog достаточно перевести её условия и ограничения в логику предикатов, описать необходимые факты и правила вывода ответов.

Языки ЛП отлично подходят для решения логических задач, задач, требующих перебора с какими-либо ограничениями (как, например, в известной задаче про расстановку ферзей на шахматной доске), где вместо продумывания реализации перебора, можно задуматься лишь о переносе задачи на логику правил и фактов.

Помимо описанных выше задач, Prolog хорошо решает задачи комбинаторики, поиска в графах, задачи на поиск в пространстве состояний (наподобие 'волк, коза и капуста'), задачи синтаксического анализа естественных и искусственных языков, задачи искусственного интеллекта.

#### Недостатки
Несмотря на все преимущества, как и любой другой язык, Prolog имеет ряд существенных недостатков.
1. *Скорость работы*

Поскольку любая задача на Прологе решается по факту "полным перебором", то в плане производительности язык уступает ряду других.

2. *Сложность описания программы*

В списке преимуществ указывалось, что достаточно перенести формулировку задачи на язык логики предикатов, но на практике, зачастую это довольно ресурсозатратно, из-за чего использование Пролога не всегда оправданно.

3. *Сложность понимания*

Одним из главных критериев чистоты и доступности языка является то, как просто легко понять принцип работы программы лишь по программному коду. В больших проектах Пролог значительно уступает в этом плане языкам, несущим в себе императивную, функциональную или объектно-ориентированную парадигмы программирования.

#### Рынок
Возвращаясь к тезису реферата и говоря об изучении логических языков прогарммирования, нельзя не упомянуть состояние рынка вакансий за последние несколько лет. Как ни странно, на рынке в основном преобладают высокоуровневые языки, сочетающие императивную, функциональную, процедурную и обобщенную парадигмы программирования. Однако лидирующие позиции удерживают также несколько декларативных языков, в часности, язык по работе с базами данных SQL. 

#### Заключение
Изучение логических языков программирования первыми, на мой взгляд, не самая лучшая идея. Для понимания общих принципов работы компьютера, способов взаимодействия с памятью и оперирования системными ресурсами, любому программисту следует начать с изучения более последовательных, императивных языков, поведение программ в которых максимально приближено к тому, по какой логике работает компьютер. Примерами таких языков отлично может послужить Си, Паскаль или Бэйсик.

В целом изучение логических языков открывает программисту новый взгляд на подходы к решению задач и представление информации, расширяет его кругозор и позволяет в случае необходимости применять декларативный подход к решению нестандартных задач.


## Список используемой литературы

1. Сошников Д.В., Парадигма логического программирования.
2. У. Клоксин, К.Меллиш, Программирование на языке Пролог.
3. Л. Стерлинг, Э. Шапиро, Искусство программирования на языке Пролог.
4. П.А. Шрайнер, Основы программирования на языке Пролог.
5. Малпас Дж., Реляционный язык Пролог и его применение.
6. Г. Ф. Довбуш, Логическое программирование.
7. http://www.swi-prolog.org/features.html
8. http://www.gprolog.org/
9. https://www.mercurylang.org/
10. https://www.visual-prolog.com/
